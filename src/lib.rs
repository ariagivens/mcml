use anyhow::{anyhow, Result};
use json::object;
use std::{
    collections::VecDeque,
    fmt::Display,
    io::{Cursor, Write},
};
use zip::ZipWriter;

pub struct Datapack {
    description: String,
    pack_format: usize,
    functions: Vec<Function>,
}

struct Function {
    namespace: String,
    name: String,
    content: String,
}

impl Datapack {
    pub fn bytes(&self) -> Result<Vec<u8>> {
        let mut zip = ZipWriter::new(Cursor::new(Vec::new()));

        let options =
            zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Stored);

        zip.start_file("pack.mcmeta", options)?;
        let metadata = object! {
            "pack": object!{
                "description": self.description.to_owned(),
                "pack_format": self.pack_format.to_owned()
            }
        };
        write!(zip, "{}", json::stringify(metadata))?;

        for function in &self.functions {
            zip.start_file(
                format!(
                    "data/{}/functions/{}.mcfunction",
                    function.namespace, function.name
                ),
                options,
            )?;
            write!(zip, "{}", function.content)?;
        }

        Ok(zip.finish()?.into_inner())
    }
}

pub fn compile(source: &str) -> Result<Datapack> {
    let functions = codegen(parse(lex(source)?)?);

    Ok(Datapack {
        description: "Datapack generated by MCML".to_owned(),
        pack_format: 18,
        functions,
    })
}

#[derive(PartialEq, Eq, Debug)]
enum Token {
    LeftParen,
    RightParen,
    Ident(String),
    Test,
    Assert,
    Boolean(bool),
    String(String),
}

impl Token {
    fn ident(s: String) -> Token {
        if &s == "test" {
            Token::Test
        } else if &s == "assert" {
            Token::Assert
        } else if &s == "true" {
            Token::Boolean(true)
        } else if &s == "false" {
            Token::Boolean(false)
        } else {
            Token::Ident(s)
        }
    }
}

impl Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::LeftParen => write!(f, "("),
            Token::RightParen => write!(f, ")"),
            Token::Ident(i) => write!(f, "{}", i),
            Token::Test => write!(f, "test"),
            Token::Assert => write!(f, "assert"),
            Token::Boolean(b) => {
                if *b {
                    write!(f, "true")
                } else {
                    write!(f, "false")
                }
            }
            Token::String(s) => write!(f, "{}", escape(s)),
        }
    }
}

fn escape(s: &str) -> String {
    let s = s.to_owned();
    let s = s.replace("\\", "\\\\");
    let s = s.replace("\"", "\\\"");
    s
}

struct Characters {
    data: Vec<char>,
    counter: usize,
}

impl Characters {
    fn new(string: String) -> Self {
        Characters {
            data: string.chars().collect(),
            counter: 0,
        }
    }
}

impl Iterator for Characters {
    type Item = char;

    fn next(&mut self) -> Option<Self::Item> {
        self.counter += 1;
        self.data.get(self.counter - 1).copied()
    }
}

fn lex(source: &str) -> Result<Vec<Token>> {
    let mut cs = Characters::new(source.to_owned()).peekable();
    let mut tokens = Vec::new();

    while let Some(c) = cs.next() {
        if c == '(' {
            tokens.push(Token::LeftParen);
        } else if c == ')' {
            tokens.push(Token::RightParen);
        } else if c.is_alphabetic() {
            let mut s = String::from(c);

            while let Some(p) = cs.peek() {
                if p.is_alphanumeric() {
                    s.push(cs.next().unwrap())
                } else {
                    break;
                }
            }

            tokens.push(Token::ident(s))
        } else if c == '"' {
            let mut s = String::new();
            while let Some(c) = cs.next() {
                if c == '"' {
                    tokens.push(Token::String(s.clone()));
                    break;
                } else if c == '\\' {
                    match cs.next() {
                        Some('"') => s.push('"'),
                        Some('\\') => s.push('\\'),
                        Some(d) => return Err(anyhow!("Unknown escape sequence \\{d} in string.")),
                        None => return Err(anyhow!("String ends with an unescaped '\\'")),
                    }
                } else {
                    s.push(c);
                }
            }
        } else if c.is_whitespace() {
        } else {
            return Err(anyhow!("Unexpected character: {}", c));
        }
    }

    Ok(tokens)
}

#[test]
fn lex_test() -> Result<()> {
    use Token::*;
    assert_eq!(
        vec![
            LeftParen,
            Test,
            String(r#"a "test" \named\ test"#.to_owned()),
            LeftParen,
            Assert,
            Boolean(true),
            Boolean(false),
            RightParen,
            RightParen
        ],
        lex(r#"(test "a \"test\" \\named\\ test" (assert true false))"#)?
    );
    Ok(())
}

#[derive(PartialEq, Eq, Debug)]
enum ASTNode {
    Test { name: String, stmt: Statement },
}

#[derive(PartialEq, Eq, Debug)]
enum Statement {
    Assert { expr: Expr },
}

#[derive(PartialEq, Eq, Debug)]
enum Expr {
    LitBool(bool),
}

struct Tokens {
    inner: VecDeque<Token>,
}

impl Tokens {
    fn new(inner: Vec<Token>) -> Self {
        Tokens {
            inner: VecDeque::from(inner),
        }
    }

    fn require(&mut self, token: Token) -> Result<()> {
        match self.inner.pop_front() {
            Some(t) if t == token => Ok(()),
            Some(t) => Err(anyhow!("Expected {} but saw {}", token, t)),
            None => Err(anyhow!("Expected {} but ran out of tokens", token)),
        }
    }

    fn next(&mut self) -> Result<Token> {
        match self.inner.pop_front() {
            Some(t) => Ok(t),
            None => Err(anyhow!("Ran out of tokens")),
        }
    }
}

fn parse(tokens: Vec<Token>) -> Result<ASTNode> {
    let mut tokens = Tokens::new(tokens);
    tokens.require(Token::LeftParen)?;
    let node = match tokens.next()? {
        Token::Test => parse_test(&mut tokens),
        _ => Err(anyhow!("Unexpected thingy")),
    }?;
    tokens.require(Token::RightParen)?;
    Ok(node)
}

fn parse_test(tokens: &mut Tokens) -> Result<ASTNode> {
    if let Token::String(name) = tokens.next()? {
        tokens.require(Token::LeftParen)?;
        let stmt = parse_stmt(tokens)?;
        Ok(ASTNode::Test { name, stmt })
    } else {
        Err(anyhow!("Expected test to have name"))
    }
}

fn parse_stmt(tokens: &mut Tokens) -> Result<Statement> {
    let stmt = match tokens.next()? {
        Token::Assert => Ok(Statement::Assert {
            expr: parse_expr(tokens)?,
        }),
        _ => Err(anyhow!("Expected a statement")),
    }?;
    tokens.require(Token::RightParen)?;
    Ok(stmt)
}

fn parse_expr(tokens: &mut Tokens) -> Result<Expr> {
    match tokens.next()? {
        Token::Boolean(b) => Ok(Expr::LitBool(b)),
        _ => Err(anyhow!("Expected an expression")),
    }
}

#[test]
fn test_parse() -> Result<()> {
    use Token::*;
    let tokens = vec![
        LeftParen,
        Test,
        String(r#"test 1"#.to_owned()),
        LeftParen,
        Assert,
        Boolean(true),
        RightParen,
        RightParen,
    ];
    assert_eq!(
        ASTNode::Test {
            name: "test 1".to_owned(),
            stmt: Statement::Assert {
                expr: Expr::LitBool(true)
            }
        },
        parse(tokens)?
    );
    Ok(())
}

fn codegen(node: ASTNode) -> Vec<Function> {
    let ASTNode::Test {
        name,
        stmt: Statement::Assert {
            expr: Expr::LitBool(b),
        },
    } = node;

    vec![
        Function {
            namespace: "mctest".to_owned(),
            name: "list".to_owned(),
            content: r#"tellraw @s "/function mctest:test1""#.to_owned(),
        },
        Function {
            namespace: "mctest".to_owned(),
            name: "test1".to_owned(),
            content: format!(
                r#"tellraw @s "{} - {}""#,
                if b { "ok" } else { "not ok" },
                escape(&name)
            ),
        },
        Function {
            namespace: "mctest".to_owned(),
            name: "plan".to_owned(),
            content: r#"tellraw @s "1..1""#.to_owned(),
        },
    ]
}
